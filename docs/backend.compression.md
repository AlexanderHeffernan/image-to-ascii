# Compression of ASCII Grid

## Overview

The compression module provides efficient compression techniques specifically designed for ASCII art generated by the image-to-ASCII converter. Since ASCII art often contains repeated characters and patterns, compression can significantly reduce the size of the output data, esecially for large images.

## Compression Methods

### 1. Run-Length Encoding (RLE)

Run-Length Encoding is particularly effective for ASCII art because:
- ASCII art often has long sequences of the same character (e.g., background spaces).
- Both color and grayscale ASCII art exhibit pattern repetition.
- Simple to implement and decode.
- Low computational overhead.

#### How RLE Works

```mermaid
graph TD;
    A[Original ASCII Grid] --> B[Scan Row by Row]
    B --> C[Count Consecutive Characters]
    C --> D[Encode as Count+Character Pairs]
    D --> E[Compressed Data]

    F[Example Inputs: 'AAABBAAA'] --> G[RLE Output: '3A2B3A']
```

#### RLE Algorithm Flow

```mermaid
flowchart TD;
    A[Start with ASCII Grid] --> B[Initialize empty result]
    B --> C[For each row]
    C --> D[Current char = first char]
    D --> E[Count = 1]
    E --> F{Next char in row?}
    F --> |Yes| G{Same as current?}
    G --> |Yes| H[Increment count]
    G --> |No| I[Add count+char to result]
    I --> J[Update current char]
    J --> K[Reset count to 1]
    H --> F
    K --> F
    F --> |No| L[Add final count+char]
    L --> M{Next row?}
    M --> |Yes| C
    M --> |No| N[Return compressed data]
```

### 2. Gzip Compression

After RLE preprocessing, gzip compression provides additional benefits:
- Handles remaining patterns that RLE doesn't catch.
- Industry-standard compression algorithm.
- Excellent compression ratios for text-based data.
- Built-in error detection and correction.
- Widely supported across platforms.

### Why RLE + Gzip is Optimal?

The combination of RLE followed by gzip creates a powerful two-stage compression process:

```mermaid
graph TD;
    A[Original ASCII Grid] --> B[Apply RLE]
    B --> C[RLE Compressed Data]
    C --> D[Apply Gzip]
    D --> E[Final Compressed Data]
```

#### Compression Pipeline

```mermaid
flowchart TD
    A[ASCII Grid with AsciiPixel] --> B[Serialize to Binary]
    B --> C[Apply RLE to Pixel Data]
    C --> D[Convert to Bytes]
    D --> E[Apply Gzip Compression]
    E --> F[Base64 Encode for Transport]
    
    G[Decompression Process] --> H[Base64 Decode]
    H --> I[Gzip Decompress]
    I --> J[Parse RLE Data]
    J --> K[Reconstruct ASCII Grid]
```

## Data Structures

### AsciiPixel Compression

Since the `AsciiPixel` struct contains both character and optional RGB color:

```rust
#[derive(Serialize)]
pub struct AsciiPixel {
    pub character: char,
    pub color: Option<[u8; 3]>,
}
```

We handl ecompression in two phases:

```mermaid
classDiagram
    class CompressedPixel {
        +char character
        +Option~RGB~ color
    }

    class RleEntry {
        +u32 count
        +CompressedPixel pixel
    }

    class CompressedGrid {
        +Vec~Vec~RleEntry~~ rows
        +u32 width
        +u32 height
        +bool has_color
    }

    CompressedGrid --> RleEntry
    RleEntry --> CompressedPixel
```

### Module Structure

```
src/compression/
├── mod.rs              # Public interface
├── rle.rs              # Run-length encoding
├── gzip.rs             # Gzip compression wrapper
└── error.rs            # Compression-specific errors
```

## Implementation Plan

- [ ] Phase 1: RLE Implementation
- [ ] Phase 2: Gzip Integration
- [ ] Phase 3: Combined Pipeline

## Performance Analysis

### Compression Ratios

### Performance Benchmarks

## Testing Strategy

### Unit Tests

### Integration Tests

## Frontend Integration